#!/usr/bin/env python3
"""
File for downloading and merging relevant data.
"""
import itertools

import cmip_data

# Toggle various activities
# NOTE: The analogy with dynamical core git packages is cmip_data:drycore for data
# generation, coupled:idealized for data processing and shared templates, and then
# timescales:constraints/transport for storing specific figure code and figure and
# manuscript output. This file is analogous to the 'post' files in 'drycore' for
# generating and merging output generated by the preliminary 'process' step.
climate = False
feedbacks = True

# Calculate the control and response climate and variance variables
# NOTE: Here time-variance quantities will only be produced for control non-cloud
# variables since most abrupt 4xCO2 experiments are not fully equilibriated. Only
# use them for year 120-150 climate estimates.
if climate:
    nodrifts = (False,)
    # nodrifts = (False, True)
    experiments = ('piControl', 'abrupt4xCO2')
    for nodrift, experiment in itertools.product(nodrifts, experiments):
        projects = ('CMIP6', 'CMIP5')
        # projects = ('CMIP5',)
        for project in projects:
            cmip_data.process_climate(
                # '~/scratch2/cmip-processed',  # TODO: move climate here
                '~/data/cmip-climate',  # source climate location
                climate='~/data/cmip-climate',  # output feedback location
                source='eraint',
                project=project,
                experiment=experiment,
                flagship_filter=True,
                overwrite=False,
                logging=True,  # ignored if dryrun true
                dryrun=False,
                nowarn=False,
                # model=['CanESM5-1', 'E3SM-2-0'],
            )

# Calculate the control, response, and anomaly feedbacks (note control anomaly
# feedbacks are impossible because cannot select a period to use for anomalies).
# NOTE: The start and stop years are python-style endpoint-exclusive and
# relative to native years.
# NOTE: The residual feedback will only be calculated if all kernels
# for the associated flux are requested. Otherwise this is bypassed.
if feedbacks:
    nodrifts = (False,)
    # nodrifts = (False, True)
    options = (
        ('piControl', False, (0, 150)),  # regression of series
        ('abrupt4xCO2', False, (0, 150)),  # regression of series
        ('abrupt4xCO2', True, (120, 150)),  # ratio of anomalies
        ('abrupt4xCO2', False, (0, 20)),  # regression of series
        ('abrupt4xCO2', False, (20, 150)),  # regression of series
        ('abrupt4xCO2', False, (0, 50)),  # regression of series
    )
    for nodrift, (experiment, ratio, response) in itertools.product(nodrifts, options):
        projects = ('CMIP6', 'CMIP5')
        # projects = ('CMIP5',)
        for project in projects:
            cmip_data.process_feedbacks(
                '~/data/cmip-climate',  # source climate location
                # '~/scratch2/cmip-processed',  # TODO: move climate here
                '~/scratch2/cmip-processed',  # source series location
                fluxes='~/scratch2/cmip-fluxes',  # intermediate flux location
                kernels='~/data/cmip-kernels',  # dependency kernels location
                feedbacks='~/data/cmip-feedbacks',  # output feedback location
                source='eraint',
                ratio=ratio,
                response=response,
                project=project,
                experiment=experiment,
                flagship_filter=True,
                nodrift=nodrift,
                overwrite=False,
                logging=True,  # ignored if dryrun true
                dryrun=False,
                nowarn=False,
                # model=['CanESM5-1', 'E3SM-2-0'],
            )
